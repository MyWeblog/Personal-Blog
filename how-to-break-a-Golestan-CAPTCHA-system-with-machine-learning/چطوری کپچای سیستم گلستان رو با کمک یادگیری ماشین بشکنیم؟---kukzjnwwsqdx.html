<html>
    <head>
        <meta charset="utf-8">
        <title>چطوری کپچای سیستم گلستان رو با کمک یادگیری ماشین بشکنیم؟</title>
        <link href="https://cdn.rawgit.com/rastikerdar/vazir-font/v18.0.1/dist/font-face.css" rel="stylesheet" type="text/css"/>
        <style>
            * {
                font-family: 'Vazir', sans-serif;
            }
            html, body {
                margin: 0;
                padding: 0;
            }
            .container{
                direction: rtl;
                margin:  20px;
            }
            h1 {
                font-size: 50px;
                margin-bottom: 17px;
                color: #333;
            }
            h2 {
                font-size: 24px;
                line-height: 1.6;
                margin: 30px 0 0 0;
                margin-bottom: 18px;
                margin-top: 33px;
                color: #333;
            }
            h3 {
                font-size: 30px;
                margin: 10px 0 20px 0;
                color: #333;
            }
            header {
                width: 640px;
                margin: auto;
            }
            section {
                width: 640px;
                margin: auto;
            }
            section p {
                margin-bottom: 27px;
                font-size: 20px;
                line-height: 1.6;
                color: #333;
            }
            section img {
                max-width: 640px;
            }
            footer {
                padding: 0 20px;
                margin: 50px 0;
                text-align: center;
                font-size: 12px;
            }
        </style>
    </head>
    <body>
        <article class="container">
            <header>
                <h1 class="p-name">چطوری کپچای سیستم گلستان رو با کمک یادگیری ماشین بشکنیم؟</h1>
            </header>
            <section class="e-content">
                <figure class="md-block-image"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/p35m1ui4lehq.png" alt="" /></figure><p class="md-block-unstyled">همه‌ی ما از کپچا (CAPTCHA) فراری ایم - همون تصاویر مزاحمی رو میگم که نوشته های درهم ریخته است و برای اینکه به فرم یا صفحه ای از سایت دسترسی داشته باشیم باید اونو تایپ کنیم. کپچاها برای تشخیص انسان از بات ها (همون برنامه های اتوماتیک) و معمولا برای جلوگیری از ورود به بخشی خاص، جلوگیری از پر کردن فرم ها یا کاهش برخی حملات طراحی شدند. جالبه بدونید در حال حاضر مدتی است که کپچاهای متنی محبوبیت خودشون رو از دست دادند و جای خودشون رو به کپچاهای تصویری یا موارد مشابه دادند.</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/fs617g2e4pyt.gif" alt="نمونه ای از کپچای گوگل جایگزین مناسبی برای کپچاهای متنی" /><figcaption className="md-block-image-caption">نمونه ای از کپچای گوگل جایگزین مناسبی برای کپچاهای متنی</figcaption></figure><p class="md-block-unstyled">سیستم گلستان رو تقریبا همه می شناسند. سیستم اتوماسیون معروف دانشگاه های ایران که پیدا کردن هر چیزی داخل اون نیازمند یک دوره دکتری تخصصی &quot;زبانهای رسمی و روش های صوری&quot; است!<br/>توی این پست قصد داریم با رویکرد آموزشی و مرحله به مرحله، شکستن کپچای متنی سیستم گلستان رو با بهره گیری از قدرت یادگیری ماشین/عمیق و داده های آماری بررسی کنیم. توصیه میشه اگر دنبال دردسر نیستید این کار رو توی خونه امتحان نکنید😉.</p><hr class="md-block-hr"/><p class="md-block-unstyled">برای شروع ماجراجویی، اول نگاهی به فرم ورود سیستم گلستان به همراه تصویر کپچای متنی می اندازیم:</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/rqpmt4fok2lo.png" alt="صفحه ورود سیستم گلستان" /><figcaption className="md-block-image-caption">صفحه ورود سیستم گلستان</figcaption></figure><p class="md-block-unstyled">توی این صفحه یک تصویر جداگانه وجود داره که از طریق آدرس تصویر میشه بهش دسترسی داشت. بنابراین قدم اول ذخیره تعداد زیادی از این تصاویر هست تا با اون ها در مرحله بعد یک شبکه عصبی مصنوعی کانولوشنال (شبکه ای برای استخراج ویژگی ها از تصاویر و کلاس بندی) رو آموزش بدیم. نهایتا شبکه آموزش داده شده میتونه تصاویر ورودی رو به متن مورد نظر ترجمه کنه. </p><h3 class="md-block-header-three">جمع آوری داده آموزشی</h3><p class="md-block-unstyled">خُب، معمولا هر الگوریتم یادگیری ماشین برای آموزش نیازمند داده های زیادی هست. شکستن کپچا هم از این قاعده مستثنی نیست. بنابراین برای اینکه بتونیم یک کپچای متنی رو بشکنیم، نیازمند تعداد زیادی تصویر هستیم. برای اینکار یک اسکریپت ساده Shell میتونه چاره کار باشه.</p><pre class="md-block-code"><span class="code-container">#! /bin/bash
# use this script for downloading Golestan CAPTCHA
for ((i=0;i &lt; 10000000;i++)){
    wget -x --no-check-certificate https://support.nowpardaz.ir/frm/captcha/captcha.ashx -O ./$i.gif
}
exit 0</span></pre><p class="md-block-unstyled">این اسکریپت سعی میکنه تعداد زیادی از فایل های تصویر رو دانلود کنه و با فرمت gif. ذخیره کنه (فرمت فایل های خروجی کدی هست که کپچا رو در سیستم اصلی تولید میکنه). </p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/iaazfwsrnb20.png" alt="نمونه ای از تصاویر کپچاهای استخراج شده از سیستم گلستان" /><figcaption className="md-block-image-caption">نمونه ای از تصاویر کپچاهای استخراج شده از سیستم گلستان</figcaption></figure><p class="md-block-unstyled">حالا حدالامکان تصاویر ورودی به سیستم رو به ساده ترین شکل ممکن تبدیل می کنیم. بدین منظور سعی میکنیم تا نوشته پایین تصاویر رو حذف کنیم.<br/>در این مطلب از کتابخونه OpenCV فریم ورک محبوب بینایی کامپیوتر و پردازش تصویر و زبان ++C برای پیش پردازش تصاویر استفاده خواهیم کرد (اگر علاقمندید این کتابخونه Python API داره و می تونید از اون هم استفاده کنید).</p><pre class="md-block-code"><span class="code-container">    Mat3b img = imread(argv[1]);    //Load image
    Rect roi(0, 0, img.cols, img.rows / 1.11);    //Setup a rectangle to define region of interest
    Mat3b crop = img(roi);    //Crop the full image to rectangle ROI
    imshow("Original", img);
    imshow("Crop", crop);</span></pre><p class="md-block-unstyled">کد بالا بخش پایین تصویر ورودی رو حذف میکنه که به عنوان یک آرگومان دریافت شده. بنابراین تا اینجای کار داده های آموزشی برای سیستم یادگیری مون رو در اختیار داریم.</p><h3 class="md-block-header-three">پیش پردازش تصاویر</h3><p class="md-block-unstyled">سیستم تشخیص کپچای ما می تونه مطابق شکل از شبکه عصبی مصنوعی برای پردازش تصاویر و برای شناسایی متن تصویر تشکیل شده باشه که یک تصویر از کپچای متنی رو به عنوان ورودی دریافت کرده و جواب صحیح رو تولید میکنه.</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/rpqadmjgarer.png" alt="رویکرد کلی سیستم یادگیری برای شکستن کپچا" /><figcaption className="md-block-image-caption">رویکرد کلی سیستم یادگیری برای شکستن کپچا</figcaption></figure><p class="md-block-unstyled">با داشتن داده های آموزشی کافی، رویکرد کلی بالا پاسخ درستی تولید می کنه؛ یعنی فقط کافیه تعداد خیلی زیادی تصویر رو به یکی از لایه های شبکه عصبی کانولوشنال (Convolutional Neural Network) (احتمالا با یک معماری پیچیده و با تعداد لایه و پارامتر زیاد) که وظیفه پردازش تصویر رو داره بدیم و با یک لایه دیگه از شبکه عصبی که وظیفه پیش بینی در مورد کل تصویر رو داره مسئله رو حل کنیم. اما این رویکرد با کمی تغییرات پاسخ های بهتر با محاسبات کمتر رو تولید میکنه. پس سعی میکنیم به جای پیش بینی کل تصویر فقط یک حرف رو پیش بینی کنیم و تصویر رو به چند تصویر شامل حروف (یا اعداد) تبدیل کنیم. واضح هست که برای تعداد زیادی تصویر راه حل فتوشاپ توصیه نمیشه!</p><p class="md-block-unstyled">خوشبختانه کپچایی که ما قصد شکستن اون رو داریم از پنج حرف تشکیل میشه. بنابراین اگر بتونیم روشی برای جداکردن حروف در تصویر داشته باشیم، شبکه عصبی تنها نیاز داره تا یک حرف رو کلاس بندی (Classify) کنه. یک روش ساده شکستن تصویر افقی به پنج قسمت مساوی هست. اما اگر به نمونه های دریافت شده در تصویر دقت کنید، ممکنه به دلیل جمع شدن حروف در یک طرف، حروف به درستی قطعه بندی (Segmentation) نشن. بنابراین برای اینکه محل دقیق تقسیم بندی در تصویر رو پیدا کنیم، سعی میکنیم تا تجمع پیکسل های غیر سفید در تصویر رو پیدا کنیم (یا به صورت ساده تعداد پیکسل در هر خط عمودی رو بشماریم)، و از اونجاییکه بین حروف فاصله کمی وجود داره، تعداد پیکسل بیشتر با تقریب خوبی جای هر حرف در تصویر رو به ما نشون میده. بعد از اینکار یک الگوریتم خوشه بندی (Clustering) می تونه به طور موثر تصویر رو به پنج بخش مختلف تقسیم کنه.</p><p class="md-block-unstyled">ابتدا باید تصویر ورودی تبدیل به تصویر سیاه و سفید بشه و بخشی از نویز اون نیز حذف بشه تا مطمئن بشیم همه چیز به بهترین نحو ممکن انجام میشه. </p><pre class="md-block-code"><span class="code-container">    //Crop image and convert to gray, blur, sharpen, bitwise_not and black-white image
    Mat img_gray, img_sharp, img_sharp_not, img_zeroone;
    cvtColor(crop, img_gray, CV_BGR2GRAY);
    blur(img_gray, img_gray, Size(4, 4));
    GaussianBlur(img_gray, img_sharp, cv::Size(0, 0), 6);
    addWeighted(img_gray, 1.80, img_sharp, -0.55, 0, img_sharp);
    bitwise_not(img_sharp, img_sharp_not);
    threshold(img_sharp_not, img_zeroone, 20, 255, THRESH_BINARY);</span></pre><p class="md-block-unstyled">کدهای بالا با پردازش تصویر، جادوی زیر رو انجام میده:</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/d548rahnyng1.png" alt="مراحل پردازش تصویر ورودی" /><figcaption className="md-block-image-caption">مراحل پردازش تصویر ورودی</figcaption></figure><p class="md-block-unstyled">برای قطعه بندی تصاویر؛ یعنی برش تصویر به کاراکترهای جداگانه، ساده ترین روش استفاده از نمودار هیستوگرام (Histogram) و یافتن دسته هایی از پیکسل هاست که در جای خاصی تجمع دارند.</p><pre class="md-block-code"><span class="code-container">    int histSize = 140;
    Mat histdata, img_sharp_not;
    bitwise_not(img_sharp, img_sharp_not);
    //Calculate the histograms for input image
    reduce(img_sharp_not, histdata, 0, CV_REDUCE_SUM, CV_32S);
    int hist_w = img.cols * 4; int hist_h = img.rows * 4;
    int bin_w = cvRound((double)hist_w / histSize);
    int txtMargin = 20;
    Mat histImage(hist_h + txtMargin, hist_w + txtMargin, CV_8UC3, Scalar(255, 255, 255));
    //Normalize the result to [ 0, histImage.rows ]
    normalize(histdata, histdata, 0, histImage.rows, NORM_MINMAX, -1, Mat());
    
    for (int i = 1; i &lt; histSize; i++){    //Draw histogram in summary
        line(histImage, Point(bin_w*(i - 1) + txtMargin, hist_h - cvRound(histdata.at&lt;int&gt;(i - 1))), Point(bin_w*(i) + txtMargin, hist_h - cvRound(histdata.at&lt;int&gt;(i))), Scalar(255, 100, 0), 2, 8, 0);
     }</span></pre><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/rhaivwdcikih.png" alt="نمودار هیستوگرام تعداد پیکسل ها برای قطعه بندی تصویر به ازای کپچای ورودی بالا سمت راست نمودار" /><figcaption className="md-block-image-caption">نمودار هیستوگرام تعداد پیکسل ها برای قطعه بندی تصویر به ازای کپچای ورودی بالا سمت راست نمودار</figcaption></figure><p class="md-block-unstyled">همون طور که در تصویر هم می بینید نقاطی که افت شدید مقدار داره، دقیقا مکان های متناظری هستند که باید تصویر برش داده بشه تا تصاویر کاراکترها استخراج بشند.</p><p class="md-block-unstyled">از اونجاییکه این روش با پیچیدگی هایی همراه هست، ما در اینجا با روش خوشه بندی k-means سعی میکنیم تا بهترین مکان برای جداسازی تصویر بعد از فیلتر رو پیدا کنیم. توی این روش از تصویر نهایی به شکل ماتریسی از صفر و یک ها (فقط نقاط سفید) که در مرحله قبل ایجاد کردیم، استفاده میکنیم. پنج نقطه اولیه تصادفی در ماتریس انتخاب میکنیم. با روش k-means سعی میکنیم نقاط درون تصویر رو به پنج خوشه (Cluster) تقسیم کنیم. نقطه مرکز هر خوشه، مرکز هر کاراکتر خواهد بود.</p><pre class="md-block-code"><span class="code-container">    //Make good representation for clustering
    Mat points = Mat::zeros(sum(img_zeroone)[0], 2, CV_32F);
    for (int i = 0, k = 0; i &lt; img_zeroone.rows; i++) {
        for (int j = 0; j &lt; img_zeroone.cols; j++) {
            if ((int)img_zeroone.at&lt;char&gt;(i, j) == 255) {
                points.at&lt;float&gt;(k, 0) = i;
                points.at&lt;float&gt;(k, 1) = j;
                k++;
            }
        }
    }
    Mat kCenters, kLabels;    //Clustering
    int clusterCount = 5, attempts = 10, iterationNumber = 1e40;
    kmeans(points, clusterCount, kLabels, TermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, iterationNumber, 1e-4), attempts, KMEANS_PP_CENTERS, kCenters);
    for (int i = 0; i &lt; kCenters.rows; i++) {
        float x = kCenters.at&lt;float&gt;(i, 1), y = kCenters.at&lt;float&gt;(i, 0);
        circle(img_sharp_not, Point(x, y), 2, (0, 0, 255), -1);
        rectangle(img_sharp_not, Rect(x - 13, y - 13, 26, 26), Scalar(255, 255, 255));
    }</span></pre><p class="md-block-unstyled">نتیجه کدهای بالا باورنکردنیه:</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/fvrtzxnghqnh.png" alt="خروجی خوشه بندی پیکسل ها برای یافتن مرکز کاراکترها و قطعه بندی تصاویر" /><figcaption className="md-block-image-caption">خروجی خوشه بندی پیکسل ها برای یافتن مرکز کاراکترها و قطعه بندی تصاویر</figcaption></figure><p class="md-block-unstyled">پردازش های بیشتری هم میشه روی تصویر انجام داد. مثلا برخی تصاویر که کنتراست (Contrast) کمتری دارند، قابلیت نرمال سازی و افزایش کنتراست رو دارند یا برای جداسازی از روش شمارش تجمعی، کاراکترهایی با طول های متفاوت رو جدا کرد. تا همین میزان پردازش برای ایجاد ورودی های شبکه عصبی؛ یعنی همون کاراکترهای جداگانه با اندازه ثابت، کافی است (اگر دوست دارید شما می تونید تا میزان دلخواه پردازش روی تصویر انجام بدید.).</p><h4 class="md-block-header-four">ساخت و آموزش شبکه عصبی مصنوعی</h4><p class="md-block-unstyled">از اونجاییکه ما فقط نیاز به تشخیص یک تصویر از حرف یا عدد داریم، نیازی به معماری پیچیده برای شبکه عصبی نداریم. شناسایی حروف یک مسئله بسیار ساده تر از تشخیص یک تصویر پیچیده (مثل تصاویری از سگ یا گربه که تنوع زیادی داره.) است. در اینجا ما برای حل مسئله شکستن کپچا از یک معماری شبکه عصبی مصنوعی با دو لایه کانولوشنال (Convolutional) همراه با Max Pooling و دو لایه تماما متصل (Fully-Connected) استفاده می کنیم. اگر شما این شبکه عصبی ها رو نمیشناسید نگران نباشید. در اینجا نیازی به پیاده سازی های سطح پایین نداریم. اگر علاقمند به یادگیری بیشتر در این زمینه هستید، <a class="md-inline-link" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" target="_blank" rel="noopener noreferrer">ویکیپدیا</a> یا <a class="md-inline-link" href="https://www.pyimagesearch.com/deep-learning-computer-vision-python-book/" target="_blank" rel="noopener noreferrer">این کتاب</a> رو بررسی کنید.</p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/sbpj28drsvta.png" alt="معماری شبکه عصبی مصنوعی کانولوشنال برای شکستن کپچا" /><figcaption className="md-block-image-caption">معماری شبکه عصبی مصنوعی کانولوشنال برای شکستن کپچا</figcaption></figure><p class="md-block-unstyled">برای سادگی آموزش در اینجا از TensorFlow؛ کتابخونه یادگیری ماشین گوگل، برای ایجاد شبکه استفاده خواهیم کرد. پیاده سازی این مدل به شکل زیر خواهد بود:</p><pre class="md-block-code"><span class="code-container">#conv1
with tf.variable_scope('conv1') as scope:
    kernel = _variable_with_weight_decay('weights', shape=[5, 5, 3, 64], stddev=5e-2, wd=None)
    conv = tf.nn.conv2d(images, kernel, [1, 1, 1, 1], padding='SAME')
    biases = _variable_on_cpu('biases', [64], tf.constant_initializer(0.0))
    pre_activation = tf.nn.bias_add(conv, biases)
    conv1 = tf.nn.relu(pre_activation, name=scope.name)
    _activation_summary(conv1)
#pool1
pool1 = tf.nn.max_pool(conv1, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='SAME', name='pool1')
#norm1
norm1 = tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')
#conv2
with tf.variable_scope('conv2') as scope:
    kernel = _variable_with_weight_decay('weights', shape=[5, 5, 64, 64], stddev=5e-2, wd=None)
    conv = tf.nn.conv2d(norm1, kernel, [1, 1, 1, 1], padding='SAME')
    biases = _variable_on_cpu('biases', [64], tf.constant_initializer(0.1))
    pre_activation = tf.nn.bias_add(conv, biases)
    conv2 = tf.nn.relu(pre_activation, name=scope.name)
    _activation_summary(conv2)
#norm2
norm2 = tf.nn.lrn(conv2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')
#pool2
pool2 = tf.nn.max_pool(norm2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='SAME', name='pool2')
#FC3
with tf.variable_scope('fc3') as scope:
    reshape = tf.reshape(pool2, [images.get_shape().as_list()[0], -1])
    dim = reshape.get_shape()[1].value
    weights = _variable_with_weight_decay('weights', shape=[dim, 384], stddev=0.04, wd=0.004)
    biases = _variable_on_cpu('biases', [384], tf.constant_initializer(0.1))
    fc3 = tf.nn.relu(tf.matmul(reshape, weights) + biases, name=scope.name)
     _activation_summary(fc3)
#FC4
with tf.variable_scope(fc4') as scope:
    weights = _variable_with_weight_decay('weights', shape=[384,192], stddev=0.04, wd=0.004)
    biases = _variable_on_cpu('biases', [192], tf.constant_initializer(0.1))
    fc4 = tf.nn.relu(tf.matmul(local3, weights) + biases, name=scope.name)
    _activation_summary(fc4)</span></pre><p class="md-block-unstyled">اگر بخش های دیگه کد رو هم به این مجموعه اضافه کنید و خوش شانس باشید خروجی زیر رو می بینید:</p><pre class="md-block-code"><span class="code-container">2018-04-25 11:45:45.927302: step 0, loss = 4.68 (2.0 examples/sec; 64.221 sec/batch)
2018-04-25 11:45:49.133065: step 10, loss = 4.66 (533.8 examples/sec; 0.240 sec/batch)
2018-04-25 11:45:51.397710: step 20, loss = 4.64 (597.4 examples/sec; 0.214 sec/batch)
2018-04-25 11:45:54.446850: step 30, loss = 4.62 (391.0 examples/sec; 0.327 sec/batch)
...</span></pre><p class="md-block-unstyled">داده های آموزشی برای این شبکه نیازمند برچسب هستند، برای اینکار می تونید مدل رو ابتدا با <a class="md-inline-link" href="https://www.nist.gov/itl/iad/image-group/emnist-dataset" target="_blank" rel="noopener noreferrer">مجموعه تصاویر EMNIST</a> آموزش بدید و بعد با تصاویر اصلی استخراج شده آموزش رو انجام بدید. دقت این مدل رو میشه به ازای داده های ورودی اندازه گرفت، نمودارهای مختلف مثل دقت-سرعت رو در زمان اجرا با استفاده از داشبورد مربوطه رصد و بررسی کرد و کلی کار دیگه که می تونه دقت و سرعت مدل رو افزایش بده. با پیاده سازی مدل یادگیری عمیق، حالا ما می تونیم به صورت خودکار کپچای سیستم گلستان رو بشکنیم! </p><hr class="md-block-hr"/><p class="md-block-unstyled">این مطلب به صورت کامل در <a class="md-inline-link" href="https://github.com/hkhojasteh" target="_blank" rel="noopener noreferrer">گیت هاب</a> در دسترس هست. همچنین اگر علاقمند به موضوعات هوش مصنوعی، یادگیری ماشین و بینایی کامپیوتر هستید می تونید<a class="md-inline-link" href="https://twitter.com/hadiakhojasteh" target="_blank" rel="noopener noreferrer"> من رو در توییتر</a> دنبال کنید.<a class="md-inline-link" href="https://twitter.com/hadiakhojasteh/status/875514318271414272" target="_blank" rel="noopener noreferrer"> </a></p><figure class="md-block-image md-block-image-has-caption"><img src="https://files.virgool.io/upload/users/7843/posts/kukzjnwwsqdx/gkyxklkq3dwg.gif" alt="ماشین خودکار هوشمند برای بازی کمپین دیجیکالا، تخفیفان و شاتل از توییتر" /><figcaption className="md-block-image-caption">ماشین خودکار هوشمند برای بازی کمپین دیجیکالا، تخفیفان و شاتل از توییتر</figcaption></figure><p class="md-block-unstyled">این ماجراجویی تموم شد. حالا نوبت شماست که دست به کار بشید، سیستم تشخیص کپچای دلخواهتون رو طراحی کنید و تجربیاتتون رو به اشتراک بذارید. به نظر شما راهکار جایگزین برای کپچاهای سنتی چه ویژگی هایی باید داشته باشه تا هوش مصنوعی نتونه اون رو بشکنه؟</p>
            </section>

                        <footer>
                <p>نوشته شده توسط
                    <a href="https://virgool.io/@hadiakhojasteh" class="p-author h-card">هادی عبدی خجسته | Hadi Abdi Khojasteh</a> در
                        <time class="dt-published" datetime="2018-04-26 16:22:20">۰۶ اردیبهشت ۱۳۹۷</time>
                    </a>.</p>
                <p>
                    <a href="https://virgool.io/@hadiakhojasteh/how-to-break-a-golestan-captcha-system-with-machine-learning-kukzjnwwsqdx"
                        class="p-canonical">لینک نوشته</a>
                </p>
                <p>برون ریزی شده از
                    <a href="https://virgool.io">ویرگول</a> در ۲۶ تیر ۱۳۹۷.</p>
            </footer>
                    </article>        
    </body>
</html>